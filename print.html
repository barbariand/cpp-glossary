<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>C++ Wiki</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="C++ Wikin förklarar konsept och exempel.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="./wiki/custom_css/mdbook-admonish.css">


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">C++ Wiki</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/barbariand/cpp-glossary" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="wikin"><a class="header" href="#wikin"><strong>Wikin</strong></a></h1>
<p>Välkommen till våran C++ Wiki!</p>
<h2 id="varför-har-vi-skrivit-wikin"><a class="header" href="#varför-har-vi-skrivit-wikin"><strong>Varför har vi skrivit Wikin</strong></a></h2>
<p>Wikin är skriven som en guide till allt i C++. Vi som skrivit den har gjort det för att dokumentera de relevanta delarna av språkets och kursens innehåll. Det ger oss möjlighet att gå tillbaka och repetera innehållet men även för andra att kunna ta del av och lära sig.</p>
<h2 id="instruktion-på-hur-man-använder-wikin"><a class="header" href="#instruktion-på-hur-man-använder-wikin"><strong>Instruktion på hur man använder Wikin</strong></a></h2>
<p>Wikin är strukturerad som en bok och kapitel kommer så gott som möjligt att endast bygga på tidigare kapitel. Målet är att ha en bok som går att följa för att lära sig C++ utan att missa vitala delar och fallgropar.</p>
<p>För att läsa wikin utan tidigare kunskaper om språket så rekommenderas det att börja från början (nästa sida) och läsa kapitel för kapitel som alla innehåller information såsom koncept, exempel och andra språkspecifika saker.</p>
<p>Kapitel kommer även i största mån att innehålla länkar till tidigare kapitel om du glömmer bort eller hoppar över koncept som har nämnts tidigare. Detta kommer även att vara faktumet för koncepten och annat som ännu inte har blivit genomgångna. Vi kommer vara tydliga med att dessa är ett hopp framåt i boken, då vi vill undvika dessa typer av hopp i allra största mån.</p>
<h2 id="tips-på-att-använda-wikin"><a class="header" href="#tips-på-att-använda-wikin"><strong>Tips på att använda Wikin</strong></a></h2>
<ol>
<li>Wikin har många små detaljer som kan vara viktiga för att förstå helheten. Därför är det bra att läsa hela texten istället för små sektioner.</li>
</ol>
<h2 id="rapport-av-misstag-och-förslag-på-förbättringar"><a class="header" href="#rapport-av-misstag-och-förslag-på-förbättringar"><strong>Rapport av misstag och förslag på förbättringar</strong></a></h2>
<p>Det kan alltid uppstå fel, misstag, slarv och annat roligt. Därför är vi oerhört tacksamma för de som väljer att skapa issues på bokens innehåll, exempel och mer.</p>
<p>Vi är tacksamma om man skapar en Issue som innefattar problemet eller förslag som man har till wikin. Genom att ha en Issue skapar det möjlighet för oss att ha en diskussion relaterat till det förslaget eller problemet.</p>
<p>Om man känner sig extra hjälpsam eller driven gällande ett problem med wikin kan man skapa en PR med ett förslag på ändring. För att skapa en PR så kan man följa denna guide: Creating a pull request - Github docs. När man skapat sin PR så kan man länka sin Issue till sin PR så blir det enklare för oss alla.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="memory"><a class="header" href="#memory">Memory</a></h1>
<p>När en applikation startar får den en bit arbetsminne (<strong>RAM</strong>) som applikationen kan använda för att utföra sina uppgifter. Vad applikationen ser är egentligen bara en lång sekvens av ettor och nollor. Det är hur dessa ettor och nollor tolkas som gör att den kan spara och läsa information från arbetsminnet.</p>
<p>Vi delar upp sekvensen av ettor och nollor i andelar, dessa kallas <strong>bits</strong> och <strong>bytes</strong>. <strong>Bit</strong> är namnet på en av dessa ettor/nollor och kan endast vara noll eller ett. Genom att kombinera flera <strong>bit</strong> kan vi få värden som är större än ett. Vi använder det <a href="https://sv.wikipedia.org/wiki/Bin%C3%A4ra_talsystemet">binära talsystemet</a> för att uppnå detta. <strong>Byte</strong> är en konvention som representerar åtta <strong>bits</strong>. Det är specifikt åtta <strong>bits</strong> eftersom <strong>ascii</strong> behövde storleken för att representera en karaktär i en sekvens av tecken. Det bara råkade vara så att det blev populärt.</p>
<p>När vi placerar flera nummer i minnet definierar vi storleken och läser från början till slut. Till exempel om vi har fyra nummer som är fyra <strong>bits</strong> stora skulle vi kunna ha följande:</p>
<p>0001001000111000</p>
<p>Vilket ger talen:</p>
<p>0001|0010|0011|1000</p>
<p>0001 = 1</p>
<p>0010 = 2</p>
<p>0011 = 3</p>
<p>1000 = 15</p>
<p>Men som sagt så vet vi inte att det är fyra nummer utan att även veta storleken på de olika talen. Det skulle även kunna läsas som:</p>
<p>0001|00100011|1000</p>
<p>eller</p>
<p>0001|0010|00111000</p>
<p>Allt beror på hur vi väljer att definiera det i vårt program.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="static-types-och-variabler"><a class="header" href="#static-types-och-variabler">Static types och variabler</a></h1>
<p>Variabler är bas för programmering, att kunna <em>hålla</em> information, <em>mutera</em> (ändra)_ _informationen och sedan <em>se</em> vilken information som variabeln håller. Det finns två vitala sätt som variabler i <em>C++</em> skiljer sig från andra språk som <em>Python</em>: <strong>Static types</strong> och <strong>lagring</strong>.</p>
<p><strong>Static types</strong> betyder att vi explicit definierar vad som kommer att ligga i en variabel. Det betyder att vi måste explicit säga att variabeln <code>my_text</code> kommer innehålla en <code>string</code>. Det finns huvudsakligen två anledningar till detta: För att veta vilka handlingar som vi kan utföra på en typ. För att veta storleken på det som ska ligga i minnet, vilket för oss in på <strong>lagring</strong>.</p>
<p><strong>Lagring</strong> i detta fall betyder vilken storlek och position i minnet som en variabel tar upp. Eftersom <em>C++</em> är ett systemspråk betyder det att det måste interagera direkt med minnet. Allt <em>C++</em> vet är det som du berättar om hur memory ser ut, inget mer. Det gör att <strong>Static types</strong> definierar ordningen och storleken på bitar i minnet.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="branching"><a class="header" href="#branching">Branching</a></h1>
<p><strong>Branching</strong> är att du med olika indata kan exekvera olika bitar av kod. Förändring på indata förändrar exekveringen av ditt program. Det enklaste exemplet att visa praktiskt på <strong>Branching</strong> är <code>if</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="condition"><a class="header" href="#condition">Condition</a></h1>
<p><a href="https://en.cppreference.com/w/cpp/language/if#Condition">Condition</a> kan vara två saker: _expression _eller _simple declaration _(läs varningen). <a href="https://en.cppreference.com/w/cpp/language/expressions">Expression</a> är saker som evalueras till något, och även assignments som evalueras till det satta värdet.</p>
<p><a href="https://en.cppreference.com/w/cpp/language/if#Condition">Condition</a> ger ett värde som bestämmer vilken <strong>branch</strong> som programmet exekverar. På grund av att <a href="https://en.cppreference.com/w/cpp/language/if#Condition">condition</a> kan innehålla så många olika saker så kan detta se ut på olika sätt. Vi kan ta några exempel:</p>
<div id="admonition-warning" class="admonition admonish-warning" role="note" aria-labelledby="admonition-warning-title">
<div class="admonition-title">
<div id="admonition-warning-title">
<p>Warning</p>
</div>
<a class="admonition-anchor-link" href="branching/condition.html#admonition-warning"></a>
</div>
<div>
<p><strong>Warning</strong>:
<a href="https://en.cppreference.com/w/cpp/language/declarations#Simple_declaration">Simple declaration</a> är en initialisering av en ny variabel (eller annan identifier). Vilket är möjligt att göra i en <a href="https://en.cppreference.com/w/cpp/language/if#Condition">Condition</a> men är oftast <strong>väldigt dumt</strong>. Det finns anledningar till att detta är möjligt, men ni behöver inte oroa er om detta. Läs mer på <a href="https://en.cppreference.com/w/cpp/language/if#Declaration">cppreference</a>.</p>
</div>
</div>
En kort sammanfattning av viktiga symboler att ha koll på:
<ul>
<li><code>==</code> betyder “lika med”</li>
<li><code>!=</code> betyder “inte lika med”</li>
<li><code>&lt;</code> betyder “mindre än”</li>
<li><code>&gt;</code> betyder “större än”</li>
<li><code>&lt;=</code> betyder “mindre eller lika med”</li>
<li><code>&gt;=</code> betyder “större eller lika med”</li>
<li><code>&amp;&amp;</code> betyder “båda måste vara true för att evaluera true”</li>
<li><code>||</code> betyder “någon måste vara true för att evaluera true”</li>
</ul>
<p>Det går att hitta fler symboler under <a href="https://en.cppreference.com/w/cpp/language/expressions">expressions</a>.</p>
<pre><code class="language-cc">4 == 4; // true
4 != 4; // false
4 == 3 || 2 == 2; // true eftersom “||” betyder “or”
// false or true vilket är true
4 == 4 &amp;&amp; 2 != 2; // false eftersom “&amp;&amp;” betyder “and”
// false and true vilket är true
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="if"><a class="header" href="#if">If</a></h1>
<p>Som sagt ovan så är <code>if</code> ett enkelt sätt att ha en <strong>branch</strong> i ett program. I <em>C++</em> så har vi tre huvudsaker som man behöver hålla reda på när man använder <code>if</code>. <code>if</code> exekverar en annan bit kod utifrån en <em>condition</em>. <code>else</code> kan följa <code>if</code>-blocket för att exekvera en bit kod ifall villkoret inte uppfylls. <a href="https://en.cppreference.com/w/cpp/language/if#Condition">Condition</a> är en bit kod som evalueras till ett värde som bestämmer vilken <strong>branch</strong> som programmet ska gå till.</p>
<h3 id="if-utan-else"><a class="header" href="#if-utan-else">If utan else</a></h3>
<pre><code class="language-cc">int main() {
  if (true) {
    // my code that will always execute
  }

  if (false) {
    // my code that will never execute
  }
}
</code></pre>
<h3 id="if-med-else"><a class="header" href="#if-med-else">If med else</a></h3>
<pre><code class="language-cc">int main() {
  if (false) {
    // my code that will never execute
  } else {
    // my code that will always execute
  }

  if (false) {
    // my code that will never execute
  } else if (true) {
    // my code that will always execute
  } else {
    // my code that will never execute
  }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="switch"><a class="header" href="#switch">Switch</a></h1>
<p><code>switch</code> är till för att matcha ints eller Enums mot flera andra ints eller enums och exekvera kod utifrån det; läs mer på <a href="https://en.cppreference.com/w/cpp/language/switch">cppreference</a>. <code>switch</code> är fundamentalt olikt till <code>if</code> även om det representerar en lösning till samma problem. Exempelvis kan det se ut såhär:</p>
<pre><code class="language-cc">switch (my_variable) {
  case 1:
    std::cout &lt;&lt; 1 &lt;&lt; std::endl;
  case 2:
    std::cout &lt;&lt; 2 &lt;&lt; std::endl;
    break;
  default:
    std::cout &lt;&lt; “default” &lt;&lt; std::endl;
}
</code></pre>
<p><code>switch</code> matchar variabeln tills att den hittar en match annars använder den default. När _control _ser en match för <code>my_variabel</code> så kommer den att börja exekvera därifrån och fortsätta genom nästa <code>case</code> tills att den träffar <code>break;</code>.</p>
<p>Om vi ansätter 1 i variabeln <code>my_variable</code> hade vi sett output:en</p>
<pre><code>1
2
</code></pre>
<p>Vi ser här att vi exekverar både fallet när <code>my_variable</code> är lika med 1 men efteråt även 2. Vi ser dock inte fallet <code>default</code> bli exekverat. Det är på grund av <code>break</code>, som avbryter exekveringen i fallet 2.</p>
<p>Om vi istället ansätter 2 i variabeln <code>my_variable</code> hade vi sett output:en</p>
<pre><code>2
</code></pre>
<p>Här ser vi endast att fallet där <code>my_variable</code> är lika med 2 exekvera.</p>
<p>Om vi ansätter någonting annat, t.ex. 3 i variabeln <code>my_variable</code> hade vi sett output:en</p>
<pre><code>default
</code></pre>
<p><code>default</code> är till för att matcha allt, oavsett vad som stoppas in i <code>switch</code>. Lägg märke till att annat blir matchat istället för <code>default</code>. Det är bra att alltid lägga <code>default</code> sist så att man kan läsa igenom alla fall och sedan se vad som sker i resten.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="scope"><a class="header" href="#scope">Scope</a></h1>
<p><strong>Scope</strong> är den fundamentala delen där dina variabler <strong>existerar</strong>. Ett <strong>scope</strong> definierar var vi kan använda variabler. När <strong>scopet</strong> har tagit slut så kommer minnet att “tas tillbaka”. Bara för att en variabel <strong>existerar</strong> betyder det inte att den <strong>lever</strong>/ är korrekt.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="lifetimes"><a class="header" href="#lifetimes">Lifetimes</a></h1>
<p>Vi kallar tiden variablen lever för en <strong>lifetime</strong>. Att leva och vara i scope är inte samma sak då lifetimen av en variable tar slut när den frigörs(free) när den förstörs/[[destrueras|Destructors]].</p>
<pre><code class="language-cc">
int A=1;                  // ----------------+-- 'a
int main() {              //                 |
    int b;                // ---------+-- 'b |
    {                     //          |      |
        int c = 5;        // -+-- 'c  |      |
        //more code       //  |       |      |
    }                     // -+       |      |
                          //          |      |
}                         // ---------+      |
                          //                 |

</code></pre>
<p>När minnet har tagits tillbaka har <strong>lifetimen</strong> tagit slut. <strong>Lifetimes</strong> definierar när vi har åtkomst till variabler och hur länge de existerar. I ovan exempel har vi 3 variabler som har <strong>lifetimes</strong> inom 3 olika <strong>scopes</strong>. <code>A</code> finns åtkomligt i hela exemplet. <code>b</code> finns åtkomligt i hela [[funktionens|Functions]] <strong>scope</strong>. <code>c</code> finns endast i det lilla inre <strong>scopet</strong>.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="global-scope"><a class="header" href="#global-scope">Global Scope</a></h1>
<p>Gällande <strong>global scope</strong> så finns det två koncept som arbetar samtidigt: Compilerns läsning av filer och exekvering av koden. Dessa två koncept definierar funktionalitet gällande <strong>global scope</strong>. Grundläggande är allt som är definierat i <strong>global scope</strong>, tillgänglig i hela programmet. Det finns ett motstridande koncept som är att C++ blir exekverat rad för rad. Den huvudsakliga filen, där <code>main</code> [[funktionen|Functions]] är definierad, i programmet är den filen som kontrollerar i vilken ordning saker kommer att bli definierade. Om saker inte finns definierade innan de är kallade i huvudfilen, anses de inte vara i <strong>global scope</strong>. Om saker är definierade, enligt i huvud-programmets exekvering, finns de i <strong>global scope</strong>. Förutsatt att de är definierade utanför något annat scope, såsom <code>main</code>-funktionen.</p>
<pre><code class="language-cc">int C = 2;                       // -------------+- 'c
                                 //              |
int main() {                     //              |
  // C finns tillgängligt        //              |
  // A finns inte tillgängligt   //              |
}                                //              |
                                 //              |
int A = 3;                       // --------+-'a |
                                 //         |    |
                                 //         |    |
</code></pre>
<p>När en variabel blir definierad i <strong>global scope</strong> är standarden att skriva variabel namnet i SCREAMING_SNAKE_CASE.</p>
<pre><code class="language-cc">int MY_GLOBAL_VARIABLE = 0;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="namespaces"><a class="header" href="#namespaces">Namespaces</a></h1>
<p><strong>Namespaces</strong> är till för att dela upp global scope. Eftersom vi refererar till saker via namn så finns det en risk att vi definierar saker flera gånger. <strong>Namespace</strong> är liksom en prefix för att lägga ytterligare distinktion till vad för något blir refererat. Samma namn riskerar att referera till flera <em>olika</em> saker.</p>
<p>Man kan likna <strong>namespaces</strong> till ett virtuellt scope som inte påverkar <em>lifetimes</em> men som tydliggör referenser till definitionerna.</p>
<h2 id="creation"><a class="header" href="#creation">Creation</a></h2>
<p>För att skapa ett nytt <strong>namespace</strong> har vi liknande syntax som att definiera ett nytt <strong>scope</strong>.</p>
<pre><code class="language-cc">namespace X {
  int Y = 0; // Y finns nu inuti namespace X
}
int Z = 1; // Z är utanför namespace X
</code></pre>
<h2 id="accessing"><a class="header" href="#accessing">Accessing</a></h2>
<p>För att komma åt en variabel eller annat som finns inuti ett <strong>namespace</strong> refererar vi till namnet på vårt <strong>namespace</strong> och namnet på vår <strong>identifier</strong> (variabel namnet t.ex.).</p>
<pre><code class="language-cc">namespace X {
  // Y finns nu inuti namespace X och i global scope
  int Y = 0;                        // ----+- 'y
}                                   //     |
int main() {                        //     |
   std::cout &lt;&lt; X::Y &lt;&lt; std::endl;  //     |
}                                   //     |
</code></pre>
<h2 id="global-scope-access"><a class="header" href="#global-scope-access">Global scope access</a></h2>
<p>Som standard har vi syntax för att gå in i <strong>namespaces</strong>, men i vissa fall vill vi gå ut ur <strong>namespaces</strong> för att referera någonting. Specifikt är detta användbart med name conflict med en variabel i global scope och nuvarande <strong>namespace</strong>.</p>
<pre><code class="language-cc">int X = 0;
namespace Y {
  int X = 2;
  …
    X // 2
    ::X // 0
  …
}
</code></pre>
<p>Vi använder syntaxen för att komma åt ett <strong>namespace</strong>, utan något namn, för att referera till global scope. Det är liksom en negation mot vår <strong>namespace</strong> nesting.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="pointers"><a class="header" href="#pointers">Pointers</a></h1>
<p>Fundamentalt är en <strong>pointer</strong> ett nummer som representerar en plats i minnet. Det finns funktionalitet för att kolla på värdet som ligger på minnesplatsen bakom <strong>pointern</strong>; platsen i minnet som värden på <strong>pointern</strong> refererar till.</p>
<p>Vi tar en <strong>pointer</strong> för att <strong>referera</strong> till en plats istället för att flytta runt värden. Istället för att flytta huset så ser du till att komma ihåg husets adress. Men du kan inte besöka huset genom att endast ha adressen till det. Du måste fysiskt ta dig till platsen där huset ligger för att kunna besöka det. Att fysiskt besöka huset skulle då representera <strong>dereference</strong> för en pointer.</p>
<p>Om du sen vill visa din kompis huset kan du bara ge vidare adressen och skapa möjligheten för din kompis att gå till huset också. På samma sätt kan du ha flera <strong>pointer</strong> till samma plats.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="referance-och-dereferance"><a class="header" href="#referance-och-dereferance">Referance och dereferance</a></h1>
<p>Två av termerna som kommer i användningen av pointers är “<strong>reference</strong>” och “<strong>dereference</strong>”. <strong>Reference</strong> betyder att du håller ett värde och tar en <strong>pointer</strong> till det värdet. <strong>Dereference</strong> är motsatsen, att du har en pointer och får ett värde.</p>
<h2 id="syntax"><a class="header" href="#syntax">Syntax</a></h2>
<p>Det finns två sätt att se <strong>pointer</strong> syntax, “types” och “values”. I <em>types</em> beskriver syntaxen “när operationen har skett, får vi underliggande typen …”. I _values _så beskriver syntaxen det faktiska operationen som sker. Det kan göra det svårt att tolka <strong>pointer</strong>-syntax.</p>
<p>Gällande värden:</p>
<ul>
<li><code>*</code> betyder “ <strong>dereference</strong> ”</li>
<li><code>&amp;</code> betyder “ <strong>reference</strong> ”</li>
</ul>
<pre><code class="language-cc">value = *pointer; // Dereferencar pointer
pointer = &amp;value; // Referencar value
</code></pre>
<p>Gällande typer där T är en type i C++:</p>
<ul>
<li><code>*</code> betyder “underliggande värdet till <strong>pointern</strong> har typen T när den är <strong>dereferenced</strong> ”</li>
</ul>
<pre><code class="language-cc">int* pointer = &amp;12; // Håller en pointer till ett värde av typen `int`
</code></pre>
<p>Det finns ytterligare syntax som används i andra områden som [[funktioner|Functions]] och [[klasser|Classes]]. Det är inte nödvändigt för att förstå __pointers __utan endast bygger på existerande funktionalitet.</p>
<h2 id="example"><a class="header" href="#example">Example</a></h2>
<p><strong>Pointers</strong> kommer <em>oftast</em> att vara annorlunda varje gång som programmet exekveras. Vi behöver inte veta varför detta sker just nu det är för säkerhet.</p>
<pre><code class="language-cc">int main() {
  int variable = 12;
  int* pointer_to_my_variable = &amp;variable;

  std::cout &lt;&lt; pointer_to_my_variable &lt;&lt; std::endl;
  // output (något i stil med):
  // 0x7fffc9d3f9a4
  int dereferenced_pointer_to_my_variable = *pointer_to_my_variable;
  std::cout &lt;&lt; dereferenced_pointer_to_my_variable &lt;&lt; std::endl;
  // output:
  // 12
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="större-data-och-pointers"><a class="header" href="#större-data-och-pointers">Större data och pointers</a></h1>
<p>Vi utgår ifrån ett program som läser in en stor fil. Om vi går in i ett nytt scope eller område av koden så skapas nya variabler för att representera datan som scopet har åtkomst till. Vi vet att filen är stor, så vi vill undvika att kopiera den till en ny variabel. Ett nummer är mycket mindre än att kopiera en hel fil, av den anledningen är <strong>pointern</strong> mycket bättre. <strong>Pointern</strong>, som då blir kopierad, pekar mot fildatan. Det ger oss möjlighet att läsa utan att kopiera. En annan positiv effekt är <em>mutability</em>. När vi ändrar kopierad data kommer det inte att representeras i det yttre scopet. Genom pointer har vi tillgång till samma data/plats som det yttre scopet; även tillgång att ändra på datan för det yttre scopet.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="scoped-pointers"><a class="header" href="#scoped-pointers">Scoped pointers</a></h1>
<p>En pointer är en variabel och detta betyder att de har en lifetime och bara kan användas i scopet som variabeln finns i. När pointers går out of scope är det bara själva numret som ges tillbaka till datorn och inte nödvändigtvis</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="array"><a class="header" href="#array">Array</a></h1>
<p>En <strong>array</strong> är, liksom variabler, ett sätt att hålla information, <em>mutera</em>(ändra) information och hämta information. Skillnaden mellan <strong>arrays</strong> och variabler är att <strong>arrays</strong> håller flera element (tänk dig variabler) som ligger efter varandra i minnet.</p>
<p>En <strong>array</strong> är egentligen en pointer till första elementet samt antalet element. Dessutom behöver vi en typ av element för att få reda på storleken för varje element.</p>
<p>En <strong>array</strong> kan inte bli större på grund av det faktum att det bara är ett sammanhängande bit minne. Vi riskerar att skriva över annan data i vårt program om vi försöker göra den större. Därför behöver vi säga till C++ hur många element vi vill ha i programmet samt vilken typ som elementen har. Olika typer har olika storlekar.</p>
<pre><code class="language-cc">int my_array[3] = {5, 2, 1}; // initialiserar [5, 2, 1]
</code></pre>
<p>För att få tag i ett element “indexerar” vi in i vår <strong>array</strong>. Vi läser en plats i <strong>arrayen</strong> utifrån dess position. För att utföra detta gör vi något som kallas “ <strong>pointer arithmetic</strong> ”, även kallat “matte med pointers”. I vanliga fall är <strong>pointer arithmetic</strong> farligt på grund av att du kan råka gå utanför det minne som du hade tänkt. Detta är även fallet här så man måste vara noga med att hålla sig till antalet element man angett.</p>
<p>Vi börjar på platsen för första elementet och sedan adderar antalet element multiplicerat med storleken på våra element. Om vi skulle räkna ut vilken pointer vi behöver ha för att nå element 2, <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span>, av en <code>int my_array[3]</code> där <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span> är vår pointer:</p>
<p><span class="katex-display"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">s</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord text"><span class="mord">storleken p</span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6944em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord">a</span></span><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.375em;"><span class="mord">˚</span></span></span></span></span></span></span><span class="mord"> en int</span></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">s</span></span></span></span></span></p>
<p><strong>Note</strong>: Det är av den anledningen som första elementet har index 0.</p>
<p>C++ har en syntax för att göra detta automatiskt, så man behöver inte tänka i dessa banor medan man programmerar. Det är bara bra att veta vad som faktiskt händer. Syntaxen som vi har är <code>[x]</code> där <code>x</code> är vår index.</p>
<p><img src="./images/array_math.png" alt="image showing array math" /></p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
